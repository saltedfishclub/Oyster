# Game

一个游戏，由参与者，阶段和状态组成。  
状态是由游戏提供的(实现 IState)，可以用来储存数据或者别的什么东西。

- NG 词
- ...

# Complex Game

~~对于复杂的游戏，自然不能只有这么点东西~~  
对于参与者和更加复杂的游戏规则，可以由阵营，队伍，规则与场地组成，不过他们都是可选的。  
对于所有的`机能`，我们将抽象为 ` Mechanic `，也就是逻辑。而游戏的「规则」正是一个 Mechanic.

# Mechanic

Mechanic，也就是机能，实际上处理或者是作出了「对应对象的动作」的控制者。  
对于一个 Mechanic，他将具有以下条件...

- 感知到事件的存在
- 感知到 tick 的发生

他总是在 tick 发生时作出动作，像 Minecraft 的大多数逻辑一样，像是...

- 对某个`标签`对应的所有对象作出动作
- 根据游戏时间进行动作
- 让你家土豆长快点

不光光是游戏。玩家，或者任何游戏要素都可以拥有 Mechanic 来比较灵活的控制游戏内容。

# Flag

实际上 Oyster 里并没有阵营~~因为我们有比阵营更加灵活的东西~~  
首先，你不应该把在 Oyster 中的队伍理解为*总是对立的*队伍，他们没有那么死板。在 Oyster 中，队伍只能代表一群人。  
而真正起到区分队伍的实际上是 `Flag`，也就是`标签` 。通过配置标签策略，我们可以做到很多事情:

- 女生宿舍 4 个人 N 个群
- 使用标签组合出更灵活的阵营，并且标签随时可变
- 让队伍内的成员条件不对等
- .....
- 让有小红帽 flag 的人名字前缀加一个小绿帽

# Team

一个 Team 代表了一组人。他们具有共享的 Flags ，但也可以有独立的个体产生额外的 Flags。  
多人游戏中，Team 总是要互相协作工作，他们之间的许多资源将会是共享的（当然，这个也由 Flag 来控制。）  
通常来说，个人拥有的 Flag 在判断时总会覆盖团队的通用 Flag。

# Rule

实质上是全局的 Mechanic，只不过只会触发 Flag，因为他的发起者是整个游戏，对象正是所有玩家。    
Flag 也与一般的不同，Rule 的 Flag *没有限制条件*，这意味着所有的 Flag 都总是运行中的。（即使你可能并没有感觉）  
比如:

- 玩家试图跑出世界边界 (Flag 将会一直关注玩家的位置，在跑出时拉回)

# GameScope

GameScope 是一块抽象的区域，`对于一个房间`，所有的游戏逻辑都将会在 GameScope 中发生。  
这通常适用于一些小游戏，例如`搭路练习`，但并不适用于**需要较多场地和独立条件**的游戏，例如`ManiHunt`    
为了使 Oyster 能够更为灵活，我们将选择的权利交给 `游戏` 而不是框架本身。Oyster 允许游戏设置对于一个服务器的 GameScope
最大承载量，并且将允许小游戏如何对场地进行划分。（区块组合，单个区块，区段，三个世界为一组，...）  
